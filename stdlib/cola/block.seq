from cola.error import ColaError
from cola.slice import ColaSlice
from cola.extends import *
import random,string

def valid_N[N:int]():
  if N < 1:
    raise ColaError()  

class CoordGrid:
  unique_id: str

  def __init__(self):
    self.unique_id = ''.join(random.choices(string.printable, k=5))

  def __eq__(self, other: CoordGrid) -> bool:
    return self.unique_id == other.unique_id
  
  def __ne__(self, other: CoordGrid) -> bool:
    return not (self == other)

# TODO restrict T to a primitive type in compiler
@dataclass(init=False)
class Multidim[T,N:int]:
  _dims: Array[int]
  _nunits: int
  _buffer: Array[T]
  _buffer_owner: Multidim[T,N]
  _cgrid: CoordGrid
  _cgrid_mapping: Array[ColaSlice]
  _is_owner: bool
  _is_root: bool

  def _common_init(self):
    valid_N[N]()

  def __init__(self, *dims):
    self._common_init()
    if staticlen(dims) != N:
      raise ColaError('Incorrect number of dims')        
    self._dims = Array[int](N)
    self._cgrid_mapping = Array[ColaSlice](N)
    idx = 0
    self._nunits = 1
    for d in dims:
      self._dims[idx] = d
      self._cgrid_mapping[idx] = ColaSlice(0,d,1)
      self._nunits *= d
      idx += 1
    self._buffer_owner = self
    self._buffer = Array[T](self.nunits())
    self._cgrid = CoordGrid()
    self._is_owner = True
    self._is_root = True

  def __init__(self, dims: Array[int]):
    self._common_init()
    if len(dims) != N:
      raise ColaError('Incorrect number of dims')        
    self._dims = Array[int](N)
    self._cgrid_mapping = Array[ColaSlice](N)
    idx = 0
    self._nunits = 1
    for d in dims:
      self._dims[idx] = d
      self._cgrid_mapping[idx] = ColaSlice(0,d,1)
      self._nunits *= d
      idx += 1
    self._buffer_owner = self
    self._buffer = Array[T](self.nunits())
    self._cgrid = CoordGrid()
    self._is_owner = True
    self._is_root = True

  def __init__(self, other: Multidim[T,N], is_owner: bool):
    self._common_init()    
    self._nunits = other._nunits
    self._dims = Array[int](N)   
    self._cgrid_mapping = Array[ColaSlice](N)
    for n in range(N):
      self._dims[n] = other._dims[n]
      self._cgrid_mapping[n] = other._cgrid_mapping[n]
    if is_owner:
      self._buffer_owner = self
      self._buffer = Array[T](self.nunits())      
    else:
      self._buffer_owner = other._buffer_owner
      self._buffer = other._buffer
    self._cgrid = other._cgrid
    self._is_owner = is_owner
    self._is_root = False

  def __init__(self, other: Multidim[T,N], cgrid_mapping: Array[ColaSlice]):
    self._common_init()
    self._cgrid_mapping = cgrid_mapping
    self._cgrid = other._cgrid
    self._buffer_owner = other._buffer_owner
    self._buffer = other._buffer
    self._dims = Array[int](N)
    self._nunits = 1  
    for idx in range(N): 
      self._dims[idx] = self._cgrid_mapping[idx].effective_sz
      self._nunits *= self._cgrid_mapping[idx].effective_sz
    self._is_owner = False
    self._is_root = False

  # make completely from scratch
  def __init__(self, cgrid_mapping: Array[ColaSlice], cgrid: CoordGrid, 
               buffer_owner: Multidim[T,N], buffer: Array[T], dims: Array[int], 
               is_owner: bool=False, is_root: bool=False):
    self._common_init()
    self._cgrid_mapping = cgrid_mapping
    self._cgrid = cgrid
    self._buffer_owner = buffer_owner
    self._buffer = buffer
    self._dims = dims
    self._is_owner = is_owner
    self._is_root = is_root
    self._nunits = 1
    for n in range(N):
      self._nunits *= dims[n]

  def dims(self) -> Array[int]:
    arr = Array[int](N)
    for n in range(N):
      arr[n] = self._dims[n]
    return arr

  def nunits(self) -> int:
    return self._nunits

  def cgrid_origin(self) -> Array[int]:
    origin = Array[int](N)
    for idx in range(N):
      origin[idx] = self._cgrid_mapping[idx].start
    return origin

  def fully_contained(self, other: Multidim[T,N]) -> Tuple[bool,Array[int]]:
    if self._cgrid != other._cgrid:
      raise ColaError('Different cgrids')
    origin = Array[int](N)
    for idx in range(N):
      this = self._cgrid_mapping[idx]
      that = other._cgrid_mapping[idx]
      this_start = this.start
      that_start = that.start
      this_stop = this.stop
      that_stop = that.stop
      this_stride = this.stride
      that_stride = that.stride
      if this_start < that_start or this_stop > that_stop:
        return (False, Array[int](0))
      rel = this_start - that_start
      # check that it is on stride line
      if rel % that_stride != 0:
        return (False, Array[int](0))
      if this_stride % that_stride != 0:
        return (False, Array[int](0))
      origin[idx] = rel
    return (True, origin)

  # check if valid within the buffer
  def exists(self):
    for idx in range(N):
      this = self._cgrid_mapping[idx]
      that = self._buffer_owner._cgrid_mapping[idx]
      this_start = this.start
      that_start = that.start
      this_stop = this.stop
      that_stop = that.stop
      this_stride = this.stride
      that_stride = that.stride
      if this_start < that_start or this_stop > that_stop:
        return False
    return True
  
  def origin_within(self, other: Multidim[T,N]) -> Array[int]:
    within,origin = self.fully_contained(other)
    if not within:
      raise ColaError('Invalid other region specified')
    return origin

  def linearize(self, coord: Array[int]) -> int:
    linear = 0
    for n in range(N):
      c = coord[n]
      for j in range(n+1,N):
        c *= self.dims()[j]
      linear += c
    return linear

  def delinearize(self, lidx: int) -> Array[int]:
    coord = Array[int](N)
    for n in range(1,N):
      mul = 1
      for j in range(n,N):
        mul *= self.dims()[j]
      coord[n-1] = lidx // mul
      lidx %= mul
    coord[N-1] = lidx
    return coord

  # TODO: bool generics
  # B => linearize final coord if 1
  # C => perform out-of-bounds check if 1 (only valid for B == 1)
  def _remap_local_lidx_to_buffer_lidx[B:int,C:int=0](self, local_lidx: int):
    # steps
    # 1. delinearize wrt this' dims to get the corresponding coordinate relative to this' logically contiguous region
    coord = self.delinearize(local_lidx)
    return self._remap_local_coord_to_buffer_lidx[B,C](coord)

  # B => linearize final coord if true
  # C => perform out-of-bounds check if true (only valid for B == true)
  def _remap_local_coord_to_buffer_lidx[B:int,C:int=0](self, local_coord: Array[int]):
    buffer_origin = self._buffer_owner.cgrid_origin()
    coord = Array[int](N)
    # 1. multiply by this' strides in each dimension to figure out the pseudo-location in cgrid
    # 2. add on this' cgrid_origin to get the true location in cgrid
    # 3. subtract buffer origin from the coord
    # 4. divide by the buffer strides    
    # 5. get relative to self
    for n in range(N):
      coord[n] = local_coord[n]
      coord[n] = (coord[n] * self._cgrid_mapping[n].stride + self._cgrid_mapping[n].start - buffer_origin[n]) // \
                 self._buffer_owner._cgrid_mapping[n].stride      
    if B == 1:
      # 6. linearize coord wrt buffer
      mapped_lidx = self._buffer_owner.linearize(coord)
      if C == 1:
        if mapped_lidx >= self._buffer_owner.nunits():
          raise ColaError('out-of-bounds')
        else:
          return mapped_lidx
      else:
        return mapped_lidx
    else:
      return coord

  def _canon(self, idx: int, _) -> ColaSlice:
    return ColaSlice(idx, idx+1, 1)
  
  def _canon(self, idx: Slice, dim: int) -> ColaSlice:
    return idx.cola_adjust(dim)

  def _canon(self, idx: ColaSlice, _) -> ColaSlice:
    return idx

  def __call__(self) -> T:
    if self.nunits() != 1:
      raise ColaError('Must only have 1 unit')
    if not self.fully_contained(self._buffer_owner)[0]:
      raise ColaError('out-of-bounds in buffer access')
    return self._buffer[self._remap_local_lidx_to_buffer_lidx[1,1](0)]  

  # if len(idxs) == 1, it is considered a linear index into the local region, even if N > 1.
  # This allows you to index with either 1 or N dimensions.
  def __call__(self, idx: int, *idxs) -> T:
    for idx in idxs:
      if not isinstance(idx, int):
        raise ColaError('__call__ can only get integers')
    if staticlen(idxs) == 0:
      x = self[(idx,)]
      return x()
    else:
      x = self[(idx,) + tuple(i for i in idxs)]
      # verify that the mapping relative to buffer is all positive (otherwise you either crash, or get an unexpected valued)
      if not x.fully_contained(self._buffer_owner)[0]:
        raise ColaError('out-of-bounds in buffer access')
      return x()

  def __call__(self, idxs: list[int]) -> T:
    x = self.__getitem__(idxs)
    # verify that the mapping relative to buffer is all positive (otherwise you either crash, or get an unexpected valued)
    if not x.fully_contained(self._buffer_owner)[0]:
      raise ColaError('out-of-bounds in buffer access')
    return x()

  # This clamps to the underlying buffer, ignoring any stride info for self
  def clamp(self, idx: int, *idxs) -> T:
    for idx in idxs:
      if not isinstance(idx, int):
        raise ColaError('clamp can only get integers')      
      #    if staticlen(idxs) == 0:
    # first get the normal access
    acc = self[(idx,) + tuple(i for i in idxs)] if staticlen(idxs) > 0 else self[idx]
    # now clamp it and use __call__
    clamped = self._clamp_to(acc, self._buffer_owner)
    return Multidim(acc, clamped)()

  def clamp(self) -> T:
    if self.nunits() != 1:
      raise ColaError('Must only have 1 unit')        
    return self.clamp(0)

  # clamp the edges of obj to the edges of clamp_to if necessary. Ignores any sort of stride on obj
  # and just clamps to clamp_to's absolute edges
  def _clamp_to(self, obj: Multidim[T,N], clamp_to: Multidim[T,N]) -> Array[ColaSlice]:
    acc_map = obj._cgrid_mapping
    buff_map = clamp_to._cgrid_mapping
    clamped = Array[ColaSlice](N)
    for n in range(N):
      am = acc_map[n]
      bm = buff_map[n]
      new_start = 0
      new_stop = 0
      if am.start < bm.start:
        new_start = bm.start
      elif am.start >= bm.stop:
        new_start = max(0, bm.stop - bm.stride)
      else:
        new_start = am.start
      if am.stop <= bm.start:
        new_stop = min(bm.stop, bm.start + bm.stride)
      elif am.stop > bm.stop:
        new_stop = bm.stop
      else:
        new_stop = am.stop
      clamped[n] = ColaSlice(new_start, new_stop, am.stride)      
    return clamped        

  def __getitem__[Z](self, idxs: list[Z]) -> Multidim[T,N]:
    canon = Array[ColaSlice](N)
    if len(idxs) != N:
      if len(idxs) == 1:
        if N != 1:
          # this is a linear idx
          if idxs[0] < 0:
            raise ColaError('linear idx must be >= 0')
        # get relative to self
        idxs2 = self.delinearize(idxs[0])
        # canonicalize idxs to ColaSlice
        for n in range(N):
          cs = self._canon(idxs2[n], self.dims()[n])
          canon[n] = cs
      else:
        raise ColaError('Incorrect number of idxs')
    else:
      # canonicalize idxs to ColaSlice
      i = 0
      for idx in idxs:
        cs = self._canon(idx, self.dims()[i])
        canon[i] = cs
        i += 1
    # now combine to map to cgrid (remember, canon is still relative to self)
    combined = Array[ColaSlice](N)
    for n in range(N):
      this = self._cgrid_mapping[n]
      that = canon[n]
      combo_start = this.start + that.start * this.stride
      combo_stop = this.start + that.stop * this.stride
      combo_stride = this.stride * that.stride
      combined[n] = ColaSlice(combo_start, combo_stop, combo_stride)
    print('combined ' + str(combined) + ' ' + str(canon) + ' ' + str(self._cgrid_mapping))
    return Multidim(self, combined)  

  # get a view on the location in self corresponding to region
  # This ignores the stride of self and other, so that region basically corresponds directly to the buffer.
  # If you want to add the stride back in, take another View of it with a strided access (this means that 
  # if region has a stride, we compute the stop using its stride and dims, but the dims of the new region
  # will be bigger since they also include the stuff that would've been skipped by the original region stride).
  # Also ignores the atom of region and uses the buffer one
  def __getitem__(self, region: Multidim[T,N]) -> Multidim[T,N]:    
    # TODO we could get rid of this requirement if we could just ensure that the cgrids were the same size or something
    if self._cgrid != region._cgrid:
      raise ColaError()  
    origin = [o2-o1-o3 for o1,o2,o3 in zip(self.cgrid_origin(), region.cgrid_origin(),self._buffer_owner.cgrid_origin())]
    for o in origin:
      if o < 0:
        raise ColaError('Location outside buffer')
    # check that the dims fall within the buffer + create the whole cgrid mapping
    mapping = Array[ColaSlice](N)
    dims = Array[int](N)
    for n in range(N):
      stop = origin[n] + region._cgrid_mapping[n].stride * region._dims[n]
      # tighten using the stride (so you don't get extra rows/cols/etc outside your region)
      cs = ColaSlice(origin[n], stop, region._cgrid_mapping[n].stride)
      # now reset the stride
      cs2 = ColaSlice(cs.start, cs.stop, 1)
      if cs2.stop > self._buffer_owner._cgrid_mapping[n].stop:
        raise ColaError('Region outside buffer')
      mapping[n] = cs2
      dims[n] = cs2.effective_sz
    return Multidim[T,N](mapping, self._cgrid, self._buffer_owner, self._buffer, dims, self._buffer_owner._atom)    

  def __getitem__(self, idx: int) -> Multidim[T,N]:
    return self.__getitem__((idx,))  
  
  # if len(idxs) == 1, it is considered a linear index into the local region, even if N > 1.
  # This allows you to index with either 1 or N dimensions.
  def __getitem__(self, idxs) -> Multidim[T,N]:
    canon = Array[ColaSlice](N)
    if staticlen(idxs) != N:
      if staticlen(idxs) == 1:
        if N != 1:
          # this is a linear idx
          if idxs[0] < 0:
            raise ColaError('linear idx must be >= 0')
        # get relative to self
        idxs2 = self.delinearize(idxs[0])
        # canonicalize idxs to ColaSlice
        for n in range(N):
          cs = self._canon(idxs2[n], self.dims()[n])
          canon[n] = cs
      else:
        raise ColaError('Incorrect number of idxs')
    else:
      # canonicalize idxs to ColaSlice
      i = 0
      for idx in idxs:
        cs = self._canon(idx, self.dims()[i])
        canon[i] = cs
        i += 1
    # now combine to map to cgrid (remember, canon is still relative to self)
    combined = Array[ColaSlice](N)
    for n in range(N):
      this = self._cgrid_mapping[n]
      that = canon[n]
      combo_start = this.start + that.start * this.stride
      combo_stop = this.start + that.stop * this.stride
      combo_stride = this.stride * that.stride
      combined[n] = ColaSlice(combo_start, combo_stop, combo_stride)
    return Multidim(self, combined)  

  # These directly access the buffer otherwise you'll infinitely recurse
  def __setitem__(self, idx: Multidim[T,N], item: T):
    sliced = self[idx]
    for s in range(sliced.nunits()):
      sliced._buffer[sliced._remap_local_lidx_to_buffer_lidx[1,1](s)] = item

  def __setitem__(self, idxs, item: T):
    sliced = self[idxs]
    for s in range(sliced.nunits()):
      sliced._buffer[sliced._remap_local_lidx_to_buffer_lidx[1,1](s)] = item

  def __setitem__[N2:int](self, idxs, item: Multidim[T,N2]):
    sliced = self[idxs]
    if sliced.nunits() != item.nunits():
      raise ColaError('Region size mismatch')
    for i in range(sliced.nunits()):
      item_elem = item(i)
      sliced._buffer[sliced._remap_local_lidx_to_buffer_lidx[1,1](i)] = item_elem

  def __iter__(self) -> Generator[Multidim[T,N]]:
    for i in range(self.nunits()):
      yield self.__getitem__((i,))

  def _get_max_str_len[I:int](self, lidx: int = 0) -> int:
    m = 0
    if I == N-1:
      for _ in range(self.dims()[I]):
        s = str(self(lidx))
        if len(s) > m:
          m = len(s)
        lidx += 1  
    elif I == N-2:
      for _ in range(self.dims()[I]):
        for _ in range(self.dims()[I+1]):          
          s = str(self(lidx))
          if len(s) > m:
            m = len(s)
          lidx += 1
    else:
      m2 = self._get_max_str_len[I+1](lidx)
      if m2 > m:
        m = m2
    return m

  def _to_str[I:int](self, max_len: int, lidx: int = 0) -> str:
    s = ''
    if I == N-1:
      for _ in range(self.dims()[I]):
        m = str(self(lidx))
        s += ' ' * (max_len - len(m) + 1) + m + ' '
        lidx += 1  
      s += '\n'
    elif I == N-2:
      for _ in range(self.dims()[I]):
        for _ in range(self.dims()[I+1]):          
          m = str(self(lidx))
          s += ' ' * (max_len - len(m) + 1) + m + ' '
          lidx += 1
        s += '\n'
      s += '\n'
    else:
      s += self._to_str[I+1](max_len, lidx)
    return s    

  def __str__(self) -> str:
    s = '========\n'
    s += self._to_str[0](self._get_max_str_len[0]())
    s += '\n' + str(self._cgrid_mapping)
    return s

  def __eq__(self, val: T) -> bool:
    if self.nunits() != 1 or self() != val:
      return False
    return True

  def __eq__(self, val: list[T]) -> bool:
    if self.nunits() != len(val):
      return False
    for i0,i1 in zip(self, val):
      if i0() != i1:
        return False
    return True

  def __eq__(self, val: Multidim[T,N]) -> bool:
    if self.nunits() != val.nunits():
      return False
    for i0,i1 in zip(self, val):
      if i0() != i1():
        return False
    return True

  # TODO operator === for this
  def loc_eq(self, other: Multidim[T,N]) -> bool:
    return self._cgrid_mapping == other._cgrid_mapping

  def default_fill(self,add):
    for i in range(self.nunits()):
      self[i] = i+add

@dataclass(init=False)
class Block[T,N:int]:
  base: Multidim[T,N]

@dataclass(init=False)
class View[T,N:int]:
  base: Multidim[T,N]

@extend
class Block[T,N:int]:

  def __init__(self, *dims):
    self.base = Multidim[T,N](*dims)
     
  def __init__(self, other: Block[T,N]):
    self.base = Multidim(other.base, True)

  def __init__(self, other: View[T,N]):
    self.base = Multidim(other.base, True)

  def __init__(self, other: Multidim[T,N]):
    self.base = other

  def dims(self) -> Array[int]:
    return self.base.dims()

  def nunits(self) -> int:
    return self.base.nunits()

  def cgrid_origin(self) -> Array[int]:
    return self.base.cgrid_origin()

  def origin_within(self, other: Block[T,N]) -> Array[int]:
    return self.base.origin_within(other.base)

  def origin_within(self, other: View[T,N]) -> Array[int]:
    return self.base.origin_within(other.base)

  def __call__(self) -> T:
    return self.base.__call__()

  def __call__(self, idx: int, *idxs) -> T:
    return self.base.__call__(idx, *idxs)

  def clamp(self, idx: int, *idxs) -> T:
    return self.base.clamp(idx, *idxs)

  def clamp(self) -> T:
    return self.base.clamp()

  def __setitem__(self, idx: Block[T,N], item: T):
    self.base[idx.base] = item

  def __setitem__(self, idx: View[T,N], item: T):
    self.base[idx.base] = item

  def __setitem__(self, idxs, item):
    self.base[idxs] = item

  def __setitem__[N2:int](self, idxs, item: Block[T,N2]):
    self.base[idxs] = item.base

  def __setitem__[N2:int](self, idxs, item: View[T,N2]):
    self.base[idxs] = item.base

  def __getitem__(self, idxs) -> View[T,N]:
    return View(self.base[idxs])

  def __getitem__(self, idx: Block[T,N]) -> View[T,N]:
    return View(self.base[idx.base]) 

  def __getitem__(self, idx: View[T,N]) -> View[T,N]:
    return View(self.base[idx.base]) 

  def __str__(self) -> str:
    return str(self.base)

  def __eq__(self, val) -> bool:
    return self.base == val

  def __eq__(self, val: Block[T,N]) -> bool:
    return self.base == val.base

  def __eq__(self, val: View[T,N]) -> bool:
    return self.base == val.base

  def __ne__(self, val) -> bool:
    return not (self == val)

  def loc_eq(self, other: View[T,N]) -> bool:
    return self.loc_eq(other.base)

  def loc_eq(self, other: Block[T,N]) -> bool:
    return self.loc_eq(other.base)

  def remap(self, cgrid: CoordGrid, location: Array[T]) -> Block[T,N]:
    return Block(self.base.remap(cgrid, location))

  def remap(self, other: Block[T,N]) -> Block[T,N]:
    return Block(self.base.remap(other.base._cgrid, other.base.cgrid_origin()))

  def buffer_owner(self) -> Block[T,N]:
    return Block(self.base._buffer_owner)

  def default_fill(self,add=0):
    self.base.default_fill(add)
    return self

@extend
class View[T,N:int]:

  def __init__(self, other: Block[T,N]):
    self.base = Multidim(other.base, False)

  def __init__(self, other: View[T,N]):
    self.base = Multidim(other.base, False)

  # for internal building
  def __init__(self, other: Multidim[T,N]):
    self.base = other

  def dims(self) -> Array[int]:
    return self.base.dims()

  def nunits(self) -> int:
    return self.base.nunits()

  def cgrid_origin(self) -> Array[int]:
    return self.base.cgrid_origin()

  def origin_within(self, other: Block[T,N]) -> Array[int]:
    return self.base.origin_within(other.base)

  def origin_within(self, other: View[T,N]) -> Array[int]:
    return self.base.origin_within(other.base)

  def __call__(self) -> T:
    return self.base.__call__()

  def __call__(self, idx: int, *idxs) -> T:
    return self.base.__call__(idx, *idxs)

  def clamp(self, idx: int, *idxs) -> T:
    return self.base.clamp(idx, *idxs)

  def clamp(self) -> T:
    return self.base.clamp()

  def exists(self) -> bool:
    return self.base.exists()

  def __setitem__(self, idx: Block[T,N], item: T):
    self.base[idx.base] = item

  def __setitem__(self, idx: View[T,N], item: T):
    self.base[idx.base] = item

  def __setitem__(self, idxs, item):
    self.base[idxs] = item

  def __setitem__[N2:int](self, idxs, item: Block[T,N2]):
    self.base[idxs] = item.base

  def __setitem__[N2:int](self, idxs, item: View[T,N2]):
    self.base[idxs] = item.base

  def __getitem__(self, idx: Block[T,N]) -> View[T,N]:
    return View(self.base[idx.base]) 

  def __getitem__(self, idx: View[T,N]) -> View[T,N]:
    return View(self.base[idx.base]) 

  def __getitem__(self, idxs) -> View[T,N]:
    return View(self.base[idxs])

  def __str__(self) -> str:
    return str(self.base)

  def __eq__(self, val) -> bool:
    return self.base == val

  def __eq__(self, val: Block[T,N]) -> bool:
    return self.base == val.base

  def __eq__(self, val: View[T,N]) -> bool:
    return self.base == val.base

  def __ne__(self, val) -> bool:
    return not (self == val)

  def loc_eq(self, other: View[T,N]) -> bool:
    return self.loc_eq(other.base)

  def loc_eq(self, other: Block[T,N]) -> bool:
    return self.loc_eq(other.base)

  def buffer_owner(self) -> Block[T,N]:
    return Block(self.base._buffer_owner)

  def remap(self, cgrid: CoordGrid, location: Array[T], buffer_owner: Block[T,N]) -> View[T,N]:
    return View(self.base.remap(cgrid, location, buffer_owner.base))

  def remap(self, cgrid: CoordGrid, location: Array[T], buffer_owner: View[T,N]) -> View[T,N]:
    return View(self.base.remap(cgrid, location, buffer_owner.base))

  def remap(self, other: View[T,N]) -> View[T,N]:
    return Block(self.base.remap(other.base._cgrid, other.base._cgrid_origin(), other.base._buffer_owner))

  def default_fill(self, add=0):
    self.base.default_fill(add)
    return self

### Arithmetic ###
# I put this separately so it doesn't clutter up the initial class defs
# Arithmetic creates a new cgrid. You can choose to remap it if you want
@extend 
class Multidim[T,N:int]:
  def __sub__(self, other: Multidim[T,N]):
    if self.dims() != other.dims():
      raise ColaError('Invalid operands ' + str(self.dims()) + ' ' + str(other.dims()))
    res = Multidim[T,N](self.dims())
    for n in range(self.nunits()):
      res[n] = self(n) - other(n)
    return res

@extend
class Block[T,N:int]:
  def __sub__(self, other: Block[T,N]) -> Block[T,N]:
    return Block(self.base - other.base)

  def __sub__(self, other: View[T,N]) -> Block[T,N]:
    return Block(self.base - other.base)

@extend
class View[T,N:int]:
  def __sub__(self, other: Block[T,N]) -> Block[T,N]:
    return Block(self.base - other.base)

  def __sub__(self, other: View[T,N]) -> Block[T,N]:
    return Block(self.base - other.base)

def run_tests():
  blk = Block[int,2](4,5).default_fill(1)
  @test
  def t0():
    assert blk.base._buffer == [r+1 for r in range(20)]
  t0()
  @test
  def t1():
    assert blk[2,3] == 14
    assert blk(2,3) == 14
    assert blk[13] == 14
    assert blk(13) == 14
  t1()
  blk2 = Block(blk[1::2,1:])
  for i in range(blk2.nunits()):    
    blk2[i] = i*10
  @test
  def t2():
    assert blk2.base._buffer == [r*10 for r in range(blk2.nunits())]
    assert blk2.dims() == [2,4]
    assert blk2.cgrid_origin() == [1,1]
    assert blk2.origin_within(blk) == [1,1]
  t2()
  view = blk2[:,::3]
  @test
  def t3():
    assert view == [0, 30, 40, 70]
    assert view.dims() == [2,2]
    assert view.cgrid_origin() == [1,1]
    assert view.origin_within(blk) == [1,1]
    assert view.origin_within(blk2) == [0,0]
  t3()
  view[1,0] = 41
  @test
  def t4():
    assert view[1,0] == [41]
  t4()
  view2 = blk2[1:,1::2]
  @test
  def t5():
    assert view2 == [50, 70]
  t5()
  view3 = blk2[1:,1:]
  @test
  def t6():
    assert view3 == [50, 60, 70]
    assert view3[:,-1:] == [41, 50, 60, 70]
  t6()
  ref4x4 = Block[int,2](4,4).default_fill(0)
  est4x4 = Block[int,2](4,4).default_fill(1)
  @test
  def t7():
    diff = ref4x4-est4x4
    assert diff == [-1] * 16
  t7()
#  @test
#  def t8():
#    force_set_ATOM(2)
#    ablk = Block[int,2]([4,8],2).default_fill()
#    assert ablk == [n for n in range(32)]
#    assert ablk.base._cgrid_mapping == [ColaSlice(0,4,1), ColaSlice(0,8,1)]
#    ablk2 = Block(ablk[1:3:1,1::2])
#    ablk2[:,:] = ablk[1:3:1,1::2]
#    assert ablk2 == [9,11,13,15,17,19,21,23]
#    assert ablk2.base._cgrid_mapping == [ColaSlice(1,3,1), ColaSlice(1,8,2)]
#    ablk3 = ablk2.set_atom(1)
#    assert ablk3.base._cgrid_mapping == [ColaSlice(1,3,1), ColaSlice(1,8,2)]
#    ablk3[0] = 88
#    ablk3[0,1] = 99
#    assert ablk3.base._buffer[0] == 88
#    assert ablk3.base._buffer[1] == 99
#    ablk4 = ablk2[0:2:1,3:4:2]
#    assert ablk4 == [15,23]
#    assert ablk4(0,-1) == 11
#    assert ablk4.clamp(0,-2) == 9
#    assert ablk4.clamp(0,-37) == 9
#    assert ablk4.clamp(1,-37) == 17
#    assert ablk4.clamp(15,12) == 23
#    force_set_ATOM(1)
##  t8()
#  @test
#  def t9():
#    force_set_ATOM(2)
#    ablk = Block[int,2](8,8).default_fill()
#    bblk = Block(ablk[::2,::2]).default_fill(10)
#    bview = bblk[1:,1:]
#    assert bview == [15,16,17,19,20,21,23,24,25]
#    assert ablk[bview] == ablk[2:7,2:7]
#    force_set_ATOM(1)
#  t9()
#  @test
#  def t10():
#    force_set_ATOM(4)
#    vals = Block[int,2]([16,16],atom=4).default_fill()
#    flags = vals.set_atom(1).default_fill(100)
##    print(vals)
##    print(flags)    
##    print(flags[vals[2,1]])
#    force_set_ATOM(1)
#  t10()
  def t11():
    ablk = Block[int,2](4,8).default_fill()
    view = ablk[:,1:7:2]
    assert view.clamp(-1,-1) == 0
    assert view.clamp(10,20) == 31
  t11()
    
run_tests()
