from cola.error import ColaError
from cola.slice import ColaSlice
from cola.extends import *
import random,string

def valid_N[N:int]():
  # TODO get rid of N>3 condition when have tuple fix
  if N < 1 or N > 3:
    raise ColaError()  

class CoordGrid[N:int]:
  """
  Represents the backing area that Blocks and Views are defined relative to.
  Blocks and Views with the same CoordGrid are part of the same spatial hierarchy.
  """

  unique_id: str
  _dims: Array[int]

  def __init__(self, dims: Array[int]):
    self.unique_id = ''.join(random.choices(string.printable, k=5))
    self._dims = Array[int](N)
    for n in range(N):
      self._dims[n] = dims[n]

  def __eq__(self, other: CoordGrid[N]) -> bool:
    return self.unique_id == other.unique_id
  
  def __ne__(self, other: CoordGrid[N]) -> bool:
    return not (self == other)

# TODO restrict T to a primitive type in compiler
@dataclass(init=False)
class Multidim[T,N:int]:
  """
  Represents a multidimensional array that tracks its location within its CoordGrid
  """

  ## The dimensions
  _dims: Array[int]
  ## The total number of units (shorthand for multiplying all the dimensions)
  _nunits: int
  ## The underlying buffer this Multidim references
  _buffer: Array[T]
  ## The owning Multidim of the buffer
  _buffer_owner: Multidim[T,N]
  ## The backing CoordGrid
  _cgrid: CoordGrid[N]
  ## This mapping to _cgrid
  _cgrid_mapping: Array[ColaSlice]
  ## Whether this Multidim owns _buffer
  _is_owner: bool
  ## Whether this Multidim was the creator of the CoordGrid
  ## _is_root == True implies _is_owner == True
  _is_root: bool

  def _common_init(self):
    valid_N[N]()

  def __init__(self, *dims):
    """
    Create a root Multidim from a set of dimensions
    """
    self._common_init()
    if staticlen(dims) != N:
      raise ColaError('Incorrect number of dims')        
    self._dims = Array[int](N)
    self._cgrid_mapping = Array[ColaSlice](N)
    idx = 0
    self._nunits = 1
    for d in dims:
      self._dims[idx] = d
      self._cgrid_mapping[idx] = ColaSlice(0,d,1)
      self._nunits *= d
      idx += 1
    self._buffer_owner = self
    self._buffer = Array[T](self.nunits())
    self._cgrid = CoordGrid[N](self._dims)
    self._is_owner = True
    self._is_root = True

  def __init__(self, dims: Array[int]):
    """
    Create a root Multidim from a set of dimensions
    """    
    self._common_init()
    if len(dims) != N:
      raise ColaError('Incorrect number of dims')        
    self._dims = Array[int](N)
    self._cgrid_mapping = Array[ColaSlice](N)
    idx = 0
    self._nunits = 1
    for d in dims:
      self._dims[idx] = d
      self._cgrid_mapping[idx] = ColaSlice(0,d,1)
      self._nunits *= d
      idx += 1
    self._buffer_owner = self
    self._buffer = Array[T](self.nunits())
    self._cgrid = CoordGrid[N](self._dims)
    self._is_owner = True
    self._is_root = True

  def __init__(self, other: Multidim[T,N], is_owner: bool):
    """
    Create a Multidim using the parameters of other. If is_owner==True,
    create a new buffer for self.
    """
    self._common_init()    
    self._nunits = other._nunits
    self._dims = Array[int](N)   
    self._cgrid_mapping = Array[ColaSlice](N)
    for n in range(N):
      self._dims[n] = other._dims[n]
      self._cgrid_mapping[n] = other._cgrid_mapping[n]
    if is_owner:
      self._buffer_owner = self
      self._buffer = Array[T](self.nunits())      
    else:
      self._buffer_owner = other._buffer_owner
      self._buffer = other._buffer
    self._cgrid = other._cgrid
    self._is_owner = is_owner
    self._is_root = False

  def __init__(self, other: Multidim[T,N], cgrid_mapping: Array[ColaSlice]):
    """
    Create a Multidim using the parameters of other, except substitute in
    the specified cgrid_mapping.
    """
    self._common_init()
    self._cgrid_mapping = cgrid_mapping
    self._cgrid = other._cgrid
    self._buffer_owner = other._buffer_owner
    self._buffer = other._buffer
    self._dims = Array[int](N)
    self._nunits = 1  
    for idx in range(N): 
      self._dims[idx] = self._cgrid_mapping[idx].effective_sz
      self._nunits *= self._cgrid_mapping[idx].effective_sz
    self._is_owner = False
    self._is_root = False

  def __init__(self, cgrid_mapping: Array[ColaSlice], cgrid: CoordGrid[N], 
               buffer_owner: Multidim[T,N], buffer: Array[T], dims: Array[int], 
               is_owner: bool=False, is_root: bool=False):
    """
    Create a Multidim with all parameters specified
    """
    self._common_init()
    self._cgrid_mapping = cgrid_mapping
    self._cgrid = cgrid
    self._buffer_owner = buffer_owner
    self._buffer = buffer
    self._dims = dims
    self._is_owner = is_owner
    self._is_root = is_root
    self._nunits = 1
    for n in range(N):
      self._nunits *= dims[n]

  def dims(self) -> Array[int]:
    """
    Return the dimensions of self
    """
    arr = Array[int](N)
    for n in range(N):
      arr[n] = self._dims[n]
    return arr

  def nunits(self) -> int:
    """
    Return the nunits of self
    """
    return self._nunits

  def origin(self) -> Array[int]:
    """
    Return the origin of self within its CoordGrid
    """
    origin = Array[int](N)
    for idx in range(N):
      origin[idx] = self._cgrid_mapping[idx].start
    return origin
  
  # doesn't do a containment check. just compares relative locations
  def origin_relative_to(self, other: Multidim[T,N]) -> Array[int]:
    """
    Return the origin of self relative to other wrt their CoordGrids 
    (which should be the same)
    """
    if self._cgrid != other._cgrid:
      raise ColaError()
    org = Array[int](N)
    for n in range(N):
      org[n] = self.origin()[n] - other.origin()[n]
    return org

  def colocate(self, surrounding_region: Multidim[T,N], other: Multidim[T,N]) -> Multidim[T,N]:
    """
    Return the region of self within other, where self and other may have different CoordGrids.
    First, self is located within surrounding_region (which should have the same cgrid as self, 
    and the same dims as other). Then, self's location in surrounding_region is used as its
    location within other. Any underlying stride of self and/or surrounding region is ignored
    when other is accessed, using only the origin and dimension information.
    """
    if surrounding_region.dims() != other.dims():
      raise ColaError()
    origin = self.origin_relative_to(surrounding_region)
    # compute the full size of self to get out of other
    area = Array[ColaSlice](N)
    for n in range(N):
      area[n] = ColaSlice(origin[n], origin[n] + self._dims[n], 1)
    colocated = other[area]
    return colocated

  def fully_contained(self, other: Multidim[T,N]) -> bool:
    """
    Check if self is fully contained within the region specified by other
    wrt their CoordGrids (which should be the same). self is fully contained
    if
    1: self's start >= other's start 
    2: self's stop <= other's stop
    """
    if self._cgrid != other._cgrid:
      raise ColaError('Different cgrids')
    for idx in range(N):
      this = self._cgrid_mapping[idx]
      that = other._cgrid_mapping[idx]
      this_start = this.start
      that_start = that.start
      this_stop = this.stop
      that_stop = that.stop
      this_stride = this.stride
      that_stride = that.stride
      if this_start < that_start or this_stop > that_stop:
        return False
    return True

  def _linearize(self, coord: Array[int]) -> int:
    """
    Return the linearization of coord relative to self.
    """
    linear = 0
    for n in range(N):
      c = coord[n]
      for j in range(n+1,N):
        c *= self.dims()[j]
      linear += c
    return linear

  def _delinearize(self, lidx: int) -> Array[int]:
    """
    Return the delinearization of the linear index lidx relative to self.
    """
    coord = Array[int](N)
    for n in range(1,N):
      mul = 1
      for j in range(n,N):
        mul *= self.dims()[j]
      coord[n-1] = lidx // mul
      lidx %= mul
    coord[N-1] = lidx
    return coord

  # TODO: bool generics
  def _remap_local_lidx_to_buffer_lidx[B:int](self, local_lidx: int):
    """
    If B == 1, return the linear index into self._buffer corresponding to local_lidx, which
    is a linear index into self. If B == 0, return the coord into self._buffer. Perform an out-of-bounds check.
    """
    coord = self._delinearize(local_lidx)
    return self._remap_local_coord_to_buffer_lidx[B](coord)

  def _remap_local_coord_to_buffer_lidx[B:int](self, local_coord: Array[int]):
    """
    If B == 1, return the linear index into self._buffer corresponding to local_coord, which
    is relative to self. If B == 0, return the coord into self._buffer. Perform an out-of-bounds check.
    """
    buffer_origin = self._buffer_owner.origin()
    coord = Array[int](N)
    # 1. multiply by this' strides in each dimension to figure out the pseudo-location in cgrid
    # 2. add on this' origin to get the true location in cgrid
    # 3. subtract buffer origin from the coord
    # 4. divide by the buffer strides    
    # 5. get relative to self
    for n in range(N):
      coord[n] = local_coord[n]
      coord[n] = (coord[n] * self._cgrid_mapping[n].stride + self._cgrid_mapping[n].start - buffer_origin[n]) // \
                 self._buffer_owner._cgrid_mapping[n].stride      
    if B == 1:
      # 6. linearize coord wrt buffer
      mapped_lidx = self._buffer_owner._linearize(coord)
      if mapped_lidx >= self._buffer_owner.nunits():
        raise ColaError('out-of-bounds')
      else:
        return mapped_lidx
    else:
      return coord

  def _canonicalize_idx(self, idx: int, _) -> ColaSlice:
    return ColaSlice(idx, idx+1, 1)
  
  def _canonicalize_idx(self, idx: Slice, dim: int) -> ColaSlice:
    return idx.cola_adjust(dim)

  def _canonicalize_idx(self, idx: ColaSlice, _) -> ColaSlice:
    return idx

  def __call__(self) -> T:
    """
    Realize the unit within this Multidim (nunits must be 1)
    """
    if self.nunits() != 1:
      raise ColaError('Must only have 1 unit')
    if not self.fully_contained(self._buffer_owner):
      raise ColaError('out-of-bounds in buffer access')
    return self._buffer[self._remap_local_lidx_to_buffer_lidx[1](0)]  

  def __call__(self, idx: int, *idxs) -> T:
    """
    Realize the unit within this Multidim at the location specified by the idxs. 
    Indexing is allowed to use either 1 or N indices. If there is 1 index, it 
    corresponds to a linear index within self. All indices are relative to self.
    """
    for idx in idxs:
      if not isinstance(idx, int):
        raise ColaError('__call__ can only get integers')
    if staticlen(idxs) == 0:
      x = self[(idx,)]
      return x()
    else:
      x = self[(idx,) + tuple(i for i in idxs)]
      # verify that the mapping relative to buffer is all positive (otherwise you either crash, or get an unexpected value)
      if not x.fully_contained(self._buffer_owner):
        raise ColaError('out-of-bounds in buffer access')
      return x()

  def clamp(self) -> T:
    """
    Like __call__, but the accessed unit location is clamped to the edges of the underlying buffer if the
    location is out-of-bounds wrt the buffer.
    """
    if self.nunits() != 1:
      raise ColaError('Must only have 1 unit')        
    return self.clamp(0)

  def clamp(self, idx: int, *idxs) -> T:
    """
    Like __call__, but the accessed unit location is clamped to the edges of the underlying buffer if the
    location is out-of-bounds wrt the buffer.
    """
    for idx in idxs:
      if not isinstance(idx, int):
        raise ColaError('clamp can only get integers')      
    # first get the normal access
    acc = self[(idx,) + tuple(i for i in idxs)] if staticlen(idxs) > 0 else self[idx]
    # now clamp it and use __call__
    clamped = acc._clamp_to(self._buffer_owner)
    return Multidim(acc, clamped)()

  def clamp(self, other: Multidim[T,N]) -> Multidim[T,N]:
    """
    Clamp the boundaries of self relative to other and return the clamped region.
    """
    if self._cgrid != other._cgrid:
      raise ColaError()
    return Multidim(self, self._clamp_to(other))

  def _clamp_to(self, clamp_to: Multidim[T,N]) -> Array[ColaSlice]:
    """
    Clamp the edges of self to clamp_to, returning the clamped region.
    """
    acc_map = self._cgrid_mapping
    buff_map = clamp_to._cgrid_mapping
    clamped = Array[ColaSlice](N)
    for n in range(N):
      am = acc_map[n]
      bm = buff_map[n]
      new_start = 0
      new_stop = 0
      if am.start < bm.start:
        new_start = bm.start
      elif am.start >= bm.stop:
        new_start = max(0, bm.stop - bm.stride)
      else:
        new_start = am.start
      if am.stop <= bm.start:
        new_stop = min(bm.stop, bm.start + bm.stride)
      elif am.stop > bm.stop:
        new_stop = bm.stop
      else:
        new_stop = am.stop
      clamped[n] = ColaSlice(new_start, new_stop, am.stride)      
    return clamped        

  def __getitem__[Z](self, idxs: list[Z]) -> Multidim[T,N]:
    """
    Get the region corresponding to idxs within self.
    """
    canon = Array[ColaSlice](N)
    if len(idxs) != N:
      if len(idxs) == 1:
        if N != 1:
          # this is a linear idx
          if idxs[0] < 0:
            raise ColaError('linear idx must be >= 0')
        # get relative to self
        idxs2 = self._delinearize(idxs[0])
        # canonicalize idxs to ColaSlice
        for n in range(N):
          cs = self._canonicalize_idx(idxs2[n], self.dims()[n])
          canon[n] = cs
      else:
        raise ColaError('Incorrect number of idxs')
    else:
      # canonicalize idxs to ColaSlice
      i = 0
      for idx in idxs:
        cs = self._canonicalize_idx(idx, self.dims()[i])
        canon[i] = cs
        i += 1
    # now combine to map to cgrid (remember, canon is still relative to self)
    combined = Array[ColaSlice](N)
    for n in range(N):
      this = self._cgrid_mapping[n]
      that = canon[n]
      combo_start = this.start + that.start * this.stride
      combo_stop = this.start + that.stop * this.stride
      combo_stride = this.stride * that.stride
      combined[n] = ColaSlice(combo_start, combo_stop, combo_stride)
    return Multidim(self, combined)  

  def __getitem__(self, other: Multidim[T,N]) -> Multidim[T,N]:    
    """
    Returns the region in self corresponding to other. Both self and other must share the same cgrid.
    Other's stride must be a multiple of self's stride, and its origin must fall on a stride line of 
    self. However, other doesn't actually need to be *within* self according to these requirements,
    so you can get things out-of-bounds. Use clamp(self0 if you want to actually constrain this (i.e.
    self[other].clamp(self)
    """
    if self._cgrid != other._cgrid:
      raise ColaError()  
    other_origin = other.origin()
    # this becomes the start of the accessed region
    relative = other.origin_relative_to(self)
    mapping = Array[ColaSlice](N)
    for n in range(N):
      # check requirements
      if other_origin[n] % (self._cgrid_mapping[n].start+self._cgrid_mapping[n].stride) != 0:
        raise ColaError('other\'s origin does not fall on self\'s stride line.')
      if other._cgrid_mapping[n].stride % self._cgrid_mapping[n].stride != 0:
        raise ColaError('other\'s stride is not a multiple of self\'s stride')
      # get the stop of other RELATIVE to self
      stop = other._cgrid_mapping[n].stop - self._cgrid_mapping[n].start-1
      # creating the mapping RELATIVE to self 
      mapping[n] = ColaSlice(relative[n]//self._cgrid_mapping[n].stride, stop//self._cgrid_mapping[n].stride+1, other._cgrid_mapping[n].stride // self._cgrid_mapping[n].stride)
    return self[mapping]

  def __getitem__(self, lidx: int) -> Multidim[T,N]:
    """
    Returns the region corresponding to the linear index lidx
    """
    return self.__getitem__((lidx,))  

  def __getitem__(self, lidx: Slice) -> Multidim[T,N]:
    """
    Returns the region corresponding to the linear index lidx
    """
    return self.__getitem__((lidx,))  

  def __getitem__(self, lidx: ColaSlice) -> Multidim[T,N]:
    """
    Returns the region corresponding to the linear index lidx
    """
    return self.__getitem__((lidx,))  

  def __getitem__[Z](self, idxs: Array[Z]) -> Multidim[T,N]:
    """
    Return the region covered by the indexes idxs. Idxs can be combinations of integers, Slices, or
    ColaSlices. Indexing is allowed to use either 1 or N indices. If there is 1 index, it 
    corresponds to a linear index within self. All indices are relative to self. 
    """
    canon = Array[ColaSlice](N)
    if len(idxs) != N:
      if len(idxs) == 1:
        if N != 1:
          # this is a linear idx
          if not isinstance(idxs[0], int) or idxs[0] < 0:
            raise ColaError('linear idx must be integer >= 0')
          # get relative to self        
          idxs2 = self._delinearize(idxs[0])
          # canonicalize idxs to ColaSlice
          for n in range(N):
            cs = self._canonicalize_idx(idxs2[n], self.dims()[n])
            canon[n] = cs
        else:
          for n in range(N):
            cs = self._canonicalize_idx(idxs[n], self.dims()[n])
            canon[n] = cs
      else:
        raise ColaError('Incorrect number of idxs (N=' + str(N) + ', len=' + str(len(idxs)) + ')')
    else:
      # canonicalize idxs to ColaSlice
      i = 0
      for idx in idxs:
        cs = self._canonicalize_idx(idx, self.dims()[i])
        canon[i] = cs
        i += 1
    # now combine to map to cgrid (remember, canon is still relative to self)
    combined = Array[ColaSlice](N)
    for n in range(N):
      this = self._cgrid_mapping[n]
      that = canon[n]
      combo_start = this.start + that.start * this.stride
      combo_stop = this.start + that.stop * this.stride
      combo_stride = this.stride * that.stride
      combined[n] = ColaSlice(combo_start, combo_stop, combo_stride)
    return Multidim(self, combined)  


  def __getitem__(self, idxs) -> Multidim[T,N]:
    """
    Return the region covered by the indexes idxs. Idxs can be combinations of integers, Slices, or
    ColaSlices. Indexing is allowed to use either 1 or N indices. If there is 1 index, it 
    corresponds to a linear index within self. All indices are relative to self. 
    """
    canon = Array[ColaSlice](N)
    if staticlen(idxs) != N:
      if staticlen(idxs) == 1:
        if N != 1:
          # this is a linear idx
          if idxs[0] < 0:
            raise ColaError('linear idx must be >= 0')
        # get relative to self
        idxs2 = self._delinearize(idxs[0])
        # canonicalize idxs to ColaSlice
        for n in range(N):
          cs = self._canonicalize_idx(idxs2[n], self.dims()[n])
          canon[n] = cs
      else:
        raise ColaError('Incorrect number of idxs (N=' + str(N) + ', len=' + str(staticlen(idxs)) + ')')
    else:
      # canonicalize idxs to ColaSlice
      i = 0
      for idx in idxs:
        cs = self._canonicalize_idx(idx, self.dims()[i])
        canon[i] = cs
        i += 1
    # now combine to map to cgrid (remember, canon is still relative to self)
    combined = Array[ColaSlice](N)
    for n in range(N):
      this = self._cgrid_mapping[n]
      that = canon[n]
      combo_start = this.start + that.start * this.stride
      combo_stop = this.start + that.stop * this.stride
      combo_stride = this.stride * that.stride
      combined[n] = ColaSlice(combo_start, combo_stop, combo_stride)
    return Multidim(self, combined)  

  def __setitem__(self, idx: Multidim[T,N], item: T):
    """
    Broadcast item to the region in self covered by idx.
    """
    sliced = self[idx]
    # Directly accesses the buffer otherwise you'll infinitely recurse
    for s in range(sliced.nunits()):
      sliced._buffer[sliced._remap_local_lidx_to_buffer_lidx[1](s)] = item

  def __setitem__(self, idxs, item: T):
    """
    Broadcast item to the region in self covered by idx.
    """
    # Directly accesses the buffer otherwise you'll infinitely recurse
    sliced = self[idxs]
    for s in range(sliced.nunits()):
      sliced._buffer[sliced._remap_local_lidx_to_buffer_lidx[1](s)] = item

  def __setitem__[N2:int](self, idxs, item: Multidim[T,N2]):
    """
    Writes units from item to the region covered by idxs. The region 
    covered by idxs and item must have the same nunits.
    """
    # Directly accesses the buffer otherwise you'll infinitely recurse
    sliced = self[idxs]
    if sliced.nunits() != item.nunits():
      raise ColaError('Region size mismatch')
    for i in range(sliced.nunits()):
      item_elem = item(i)
      sliced._buffer[sliced._remap_local_lidx_to_buffer_lidx[1](i)] = item_elem
  
  def __iter__(self) -> Generator[Multidim[T,N]]:
    """
    Iterate over the individual units of self, returning a new Multidim representing
    each units location.
    """
    for i in range(self.nunits()):
      yield self.__getitem__((i,))

  def _get_max_str_len[I:int](self, lidx: int = 0) -> int:
    m = 0
    if I == N-1:
      for _ in range(self.dims()[I]):
        s = str(self(lidx))
        if len(s) > m:
          m = len(s)
        lidx += 1  
    elif I == N-2:
      for _ in range(self.dims()[I]):
        for _ in range(self.dims()[I+1]):          
          s = str(self(lidx))
          if len(s) > m:
            m = len(s)
          lidx += 1
    else:
      m2 = self._get_max_str_len[I+1](lidx)
      if m2 > m:
        m = m2
    return m

  def _to_str[I:int](self, max_len: int, lidx: int = 0) -> str:
    s = ''
    if I == N-1:
      for _ in range(self.dims()[I]):
        m = str(self(lidx))
        s += ' ' * (max_len - len(m) + 1) + m + ' '
        lidx += 1  
      s += '\n'
    elif I == N-2:
      for _ in range(self.dims()[I]):
        for _ in range(self.dims()[I+1]):          
          m = str(self(lidx))
          s += ' ' * (max_len - len(m) + 1) + m + ' '
          lidx += 1
        s += '\n'
      s += '\n'
    else:
      s += self._to_str[I+1](max_len, lidx)
    return s    

  def __str__(self) -> str:
    s = '========\n'
    s += self._to_str[0](self._get_max_str_len[0]())
    s += '\n' + str(self._cgrid_mapping)
    return s

  def __eq__(self, val: T) -> bool:
    if self.nunits() != 1 or self() != val:
      return False
    return True

  def __eq__(self, val: list[T]) -> bool:
    if self.nunits() != len(val):
      return False
    for i0,i1 in zip(self, val):
      if i0() != i1:
        return False
    return True

  def __eq__(self, val: Multidim[T,N]) -> bool:
    if self.nunits() != val.nunits():
      return False
    for i0,i1 in zip(self, val):
      if i0() != i1():
        return False
    return True

  # TODO operator === for this
  def loc_eq(self, other: Multidim[T,N]) -> bool:
    """
    Check if the location of self and other is the same (ignoring if their 
    cgrids are the same or not)
    """
    return self._cgrid_mapping == other._cgrid_mapping

  def default_fill(self,add):
    for i in range(self.nunits()):
      self[i] = i+add

@dataclass(init=False)
class Block[T,N:int]:
  base: Multidim[T,N]

@dataclass(init=False)
class View[T,N:int]:
  base: Multidim[T,N]

@extend
class Block[T,N:int]:

  def __init__(self, *dims):
    self.base = Multidim[T,N](*dims)
     
  def __init__(self, other: Block[T,N]):
    self.base = Multidim(other.base, True)

  def __init__(self, other: View[T,N]):
    self.base = Multidim(other.base, True)

  def __init__(self, other: Multidim[T,N]):
    self.base = other

  def dims(self) -> Array[int]:
    return self.base.dims()

  def nunits(self) -> int:
    return self.base.nunits()

  def origin(self) -> Array[int]:
    return self.base.origin()

  def origin_relative_to(self, other: Block[T,N]) -> Array[int]:
    return self.base.origin_relative_to(other.base)

  def origin_relative_to(self, other: View[T,N]) -> Array[int]:
    return self.base.origin_relative_to(other.base)

  def __call__(self) -> T:
    return self.base.__call__()

  def __call__(self, idx: int, *idxs) -> T:
    return self.base.__call__(idx, *idxs)

  def __setitem__(self, idx: Block[T,N], item: T):
    self.base[idx.base] = item

  def __setitem__(self, idx: View[T,N], item: T):
    self.base[idx.base] = item

  def __setitem__(self, idxs, item):
    self.base[idxs] = item

  def __setitem__[N2:int](self, idxs, item: Block[T,N2]):
    self.base[idxs] = item.base

  def __setitem__[N2:int](self, idxs, item: View[T,N2]):
    self.base[idxs] = item.base

  def __getitem__(self, idxs) -> View[T,N]:
    return View(self.base[idxs])

  def __getitem__(self, idx: Block[T,N]) -> View[T,N]:
    return View(self.base[idx.base]) 

  def __getitem__(self, idx: View[T,N]) -> View[T,N]:
    return View(self.base[idx.base]) 

  def __str__(self) -> str:
    return str(self.base)

  def __eq__(self, val) -> bool:
    return self.base == val

  def __eq__(self, val: Block[T,N]) -> bool:
    return self.base == val.base

  def __eq__(self, val: View[T,N]) -> bool:
    return self.base == val.base

  def __ne__(self, val) -> bool:
    return not (self == val)

  def loc_eq(self, other: View[T,N]) -> bool:
    return self.base.loc_eq(other.base)

  def loc_eq(self, other: Block[T,N]) -> bool:
    return self.base.loc_eq(other.base)

  def buffer_owner(self) -> Block[T,N]:
    return Block(self.base._buffer_owner)

  def default_fill(self,add=0):
    self.base.default_fill(add)
    return self

@extend
class View[T,N:int]:

  def __init__(self, other: Block[T,N]):
    self.base = Multidim(other.base, False)

  def __init__(self, other: View[T,N]):
    self.base = Multidim(other.base, False)

  # for internal building
  def __init__(self, other: Multidim[T,N]):
    self.base = other

  def dims(self) -> Array[int]:
    return self.base.dims()

  def nunits(self) -> int:
    return self.base.nunits()

  def origin(self) -> Array[int]:
    return self.base.origin()

  def origin_relative_to(self, other: Block[T,N]) -> Array[int]:
    return self.base.origin_relative_to(other.base)

  def origin_relative_to(self, other: View[T,N]) -> Array[int]:
    return self.base.origin_relative_to(other.base)

  def __call__(self) -> T:
    return self.base.__call__()

  def __call__(self, idx: int, *idxs) -> T:
    return self.base.__call__(idx, *idxs)

  def clamp(self, idx: int, *idxs) -> T:
    return self.base.clamp(idx, *idxs)

  def clamp(self) -> T:
    return self.base.clamp()

  def clamp(self, other: Block[T,N]) -> View[T,N]:
    return View(self.base.clamp(other.base))

  def clamp(self, other: View[T,N]) -> View[T,N]:
    return View(self.base.clamp(other.base))
  
  def exists(self) -> bool:
    return self.base.fully_contained()

  def __setitem__(self, idx: Block[T,N], item: T):
    self.base[idx.base] = item

  def __setitem__(self, idx: View[T,N], item: T):
    self.base[idx.base] = item

  def __setitem__(self, idxs, item):
    self.base[idxs] = item

  def __setitem__[N2:int](self, idxs, item: Block[T,N2]):
    self.base[idxs] = item.base

  def __setitem__[N2:int](self, idxs, item: View[T,N2]):
    self.base[idxs] = item.base

  def __getitem__(self, idx: Block[T,N]) -> View[T,N]:
    return View(self.base[idx.base]) 

  def __getitem__(self, idx: View[T,N]) -> View[T,N]:
    return View(self.base[idx.base]) 

  def __getitem__(self, idxs) -> View[T,N]:
    return View(self.base[idxs])

  def __str__(self) -> str:
    return str(self.base)

  def __eq__(self, val) -> bool:
    return self.base == val

  def __eq__(self, val: Block[T,N]) -> bool:
    return self.base == val.base

  def __eq__(self, val: View[T,N]) -> bool:
    return self.base == val.base

  def __ne__(self, val) -> bool:
    return not (self == val)

  def loc_eq(self, other: View[T,N]) -> bool:
    return self.base.loc_eq(other.base)

  def loc_eq(self, other: Block[T,N]) -> bool:
    return self.base.loc_eq(other.base)

  def buffer_owner(self) -> Block[T,N]:
    return Block(self.base._buffer_owner)

  def default_fill(self, add=0):
    self.base.default_fill(add)
    return self

### Arithmetic ###
# I put this separately so it doesn't clutter up the initial class defs
# Arithmetic creates a new cgrid. You can choose to remap it if you want
@extend 
class Multidim[T,N:int]:
  def __sub__(self, other: Multidim[T,N]):
    if self.dims() != other.dims():
      raise ColaError('Invalid operands ' + str(self.dims()) + ' ' + str(other.dims()))
    res = Multidim[T,N](self.dims())
    for n in range(self.nunits()):
      res[n] = self(n) - other(n)
    return res

@extend
class Block[T,N:int]:
  def __sub__(self, other: Block[T,N]) -> Block[T,N]:
    return Block(self.base - other.base)

  def __sub__(self, other: View[T,N]) -> Block[T,N]:
    return Block(self.base - other.base)

@extend
class View[T,N:int]:
  def __sub__(self, other: Block[T,N]) -> Block[T,N]:
    return Block(self.base - other.base)

  def __sub__(self, other: View[T,N]) -> Block[T,N]:
    return Block(self.base - other.base)

def run_tests():
  blk = Block[int,2](4,5).default_fill(1)
  @test
  def t0():
    assert blk.base._buffer == [r+1 for r in range(20)]
  t0()
  @test
  def t1():
    assert blk[2,3] == 14
    assert blk(2,3) == 14
    assert blk[13] == 14
    assert blk(13) == 14
  t1()
  blk2 = Block(blk[1::2,1:])
  for i in range(blk2.nunits()):    
    blk2[i] = i*10
  @test
  def t2():
    assert blk2.base._buffer == [r*10 for r in range(blk2.nunits())]
    assert blk2.dims() == [2,4]
    assert blk2.origin() == [1,1]
    assert blk2.origin_relative_to(blk) == [1,1]
  t2()
  view = blk2[:,::3]
  @test
  def t3():
    assert view == [0, 30, 40, 70]
    assert view.dims() == [2,2]
    assert view.origin() == [1,1]
    assert view.origin_relative_to(blk) == [1,1]
    assert view.origin_relative_to(blk2) == [0,0]
  t3()
  view[1,0] = 41
  @test
  def t4():
    assert view[1,0] == [41]
  t4()
  view2 = blk2[1:,1::2]
  @test
  def t5():
    assert view2 == [50, 70]
  t5()
  view3 = blk2[1:,1:]
  @test
  def t6():
    assert view3 == [50, 60, 70]
    assert view3[:,-1:] == [41, 50, 60, 70]
  t6()
  ref4x4 = Block[int,2](4,4).default_fill(0)
  est4x4 = Block[int,2](4,4).default_fill(1)
  @test
  def t7():
    diff = ref4x4-est4x4
    assert diff == [-1] * 16
  t7()
  @test
  def t8():
    ablk = Block[int,2](4,8).default_fill()
    view = ablk[:,1:7:2]
    assert view.clamp(-1,-1) == 0
    assert view.clamp(10,20) == 31
    view2 = view[-1:10,-13:3]
    assert view2.clamp(view) == view
    assert view2.clamp(ablk) == ablk[:,:6:2]
  t8()
  @test
  def t9():
    blk = Block[int,1](20).default_fill()
    print(blk)
    view = blk[1:11:3]
    print(view)
    view2 = blk[4::6]
    print(view2)
    view3 = view[view2]
    print(view3)
    view4 = view3.clamp(view)
    print(view4)
  t9()
    
run_tests()
